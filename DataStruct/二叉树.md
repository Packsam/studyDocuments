# 二叉树
## 链式存储
### 二叉树的遍历
二叉树的遍历分为3种，前序中序和后序，其分别为遍历顺序为：  
前序：本身，左节点，右节点  
中序：左节点，本身，右节点  
后序：左节点，右节点，本身  
在代码实现的区别在于 输出本身的语句在递归调用的前还是后：  
左递归：  
`if(lnode!=null)`  
`lnode.shows()`  
右递归：  
`if(lnode!=null)`  
`lnode.shows()`  
前序输出在两递归之前，中序在之间，后序在后面。

### 二叉树的节点查找
节点查找和遍历相似

### 二叉树的节点删除
二叉树的节点删除从根节点开始，若  
`this.value == target`  
`this = null`即可  
然后进行递归，左递归和右递归，递归时要判断是否为null  
`if(lnode!=null)`    
`delete(lnode)`  
`if(rnode!=null)`  
`delete(rnode)`

## 顺序存储
顺序存储的二叉树通常只考虑完全二叉树，节点n的左子节点为2n+1，右子节点为2n+2，任何节点的父节点为(n-1)/2  
顺序存储的二叉树的遍历：调用的时候传入节点的index就可，但是注意需要判断`index<Tree.length`仍可通过控制输出语句的位置来控制前中后序遍历。

## 堆排序
大顶堆父节点永远比子节点大，小顶堆刚好相反，升序排用大顶堆，降序用小顶堆。
把一个二叉树转换为大顶堆，方法是从最后一个非叶子节点开始，与其子节点比较，若比子节点还小，则交换位置。但交换位置后可能会破坏之前排好的堆，所以还需要在被调整位置递归调用排序。
调整函数`maxHeap(int[] arr,int size,int index)` index 为被处理的位置，每次调用的index的值都比之前的向前一位，size控制排序的范围。
堆排序就是，每次都将现有的数组调整为大顶堆，然后把排在最前的（就是最大的）放在最后面，然后控制调整范围，再把前面的继续调整为大顶堆，循环如此操作即排序完成。

## 线索二叉树
线索化二叉树时，用节点空余的指针，根据不同的线索化序，来指向他的前驱或者后继节点。并通过flag指示该指针指向左子节点还是前驱，或者右子节点还是后继。
另外需要一个指针用来存储前驱节点。
线索化二叉树需要递归调用，根据不同的线索化顺序，则决定给前驱指针和后继指针的赋值语句位置。在递归之前要先判断左子节点或右子节点是否存在。当然在递归之前也应该先判断本身是否为空。  
线索化本身的代码为：  
`if(node.lnode == null)`  
`node.lnode = pre//指针线索化把左指针指向前驱`  
`lflag = 1`
`if(pre!=null&&pre.rnode==null)//前驱没有右子节点`  
`pre.node = node`  
`pre.rflag = 1`

## 线索二叉树的遍历
先通过根节点找到初始节点，从root一直找lnode直至lflag==1停下。然后遍历他的rnode直至rflag==0为一次循环停止，再执行这个过程
`while(node!=null){`  
`if(node.lflag == 0 )` 
`node = node.lnode`   
`syso node.value`  
`if(node.rflag ==1){`  
`node = node.rnode`  
`syso node.value}`
`node = node.rnode//一次循环结束，让节点指向其后继，开始下一次循环`

## 赫夫曼树（最优二叉树）
叶节点的带权路径长度之和最小的二叉树。sum(权值*长度)。  
构建方法，先将节点按权值排序，然后取出2个权值最小的节点，放在最下面并按其权值之和构建一个根节点，之后将根节点列入比较范围，循环这个过程。
首先构建一个树节点集合，然后循环：  
1、排序，找到权值最小的2个节点  
2、根据两个节点构建parents节点，并设置左右指针  
3、把这两个节点从原集合中删除，再把parents放回去。

## 赫夫曼编码
用赫夫曼树来构建编码，将所有字符放在叶子节点上，然后将其出现次数作为权值进行赫夫曼树构建。

## 二叉排序树BST
对于以个非叶子节点，要求其左子节点的值比自己的值小，右子节点大。这样构建的二叉排序树查找性能很高
### 二叉排序树的节点插入
首先判断根节点是否为空，若为空则放到根节点。然后判断值的大小，大于（小于）则判断左子节点（右子节点）是否为空，若为空则插入，不为空则进行递归调用。

### 二叉排序树查找节点
首先判断是否为空，如果与当前值相等则直接返回，若小则递归调用左节点，大则递归调用右节点。

### 二叉排序树的删除节点
二叉排序树节点的删除还需要依赖于目标节点的父节点，所以需要通过递归实现寻找父节点。  
删除拥有单子节点的节点时，需要先判断被删除的节点是父节点的左子节点还是右子节点，然后判断被删除节点拥有的是左子节点还是右子节点，让后将子节点连至父节点处。
删除拥有两个子节点的节点时，先删除被删除节点的右子数中值最小的节点（从右子节点开始往左找）（用上面的删除方式），并保存该值，直接将这个值代替被删除节点就可以了。

## 平衡二叉树 AVL
任何一个节点的左子树和右字数的高度差不超过1
平衡二叉树的单旋转：
