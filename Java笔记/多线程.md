# 多线程
实现线程的方法：1、继承Thread类 2、实现Runnable接口 3、实现Callable接口  
Java虚拟机会等用户线程结束而不会等守护线程。  
实现线程时，必须重写Run方法，同时开启线程，是调用其Start方法，而不是Run方法。  
使用实现Runnable接口的方法创建线程时，注意Runnable并没有Start方法，必须创建一个Thread对象，以这个线程对象为构造参数，并调用Start  
e.g.  
`class A implements Runnable{}`  
`A a = new A()`  
`new Thread(a，str).start()`//a 不可以直接调用start，start是Thread的方法,str代表线程名称。  
当这种方法下，线程只使用一次，那么可以使用匿名类，而不用创建真正的A的对象。  
另外多线程操作相同资源时，多个Thread使用同样的A对象，但是构造器处传入不同的Thread名称。

e.g.  
`class A extends Thread{`  
`run(){}`//重写run方法  
`}`  
`A a = new A()`  
`a.start()`//调用Start，但并不一定立即执行，需要看CPU的分配  
注意Run方法不可以返回值，也不可以抛出异常。

第三种方法中，实现callable接口，不需要重写run方法，而是重写call方法  
call方法比run方法强大，可以抛出异常。但是在实现线程时需要借助服务，也不是调用start而是调用submit方法。  
最后需要释放资源，关闭服务，shutdownNow()

## 代理模式
### 静态代理  
两个角色：真实角色和代理角色。这两个角色都必须实现同一个接口。  
代理角色中必须有以接口为引用类型的真实角色对象成员。   
两个角色对接口中的方法分别进行不同的重写。

接口：  
`interface A{`  
`void hello()}`  
真实对象  
`class B implements A{`  
`public void hello(){}`  
代理对象  
`class C implements A{`
`private A m_a`  
`public void hello(){}`

`main(){`  
`new C(new B()).hello()}`

## λ表达式
用于简化简单的线程类：
外部类→静态内部类→局部内部类→匿名内部类→lambda表达式  
外部类：  
`interface A{`  
`void hello()}`  

`class B implements A{`  
`public void hello(){}}`  

`main(){`  
`A a = new B()`  
`a.hello()`  

静态内部类：把B写在Demo类内部  

`static class B implements A{`  
`public void hello(){}}`  
 
局部内部类:把类B写在方法中
 
`main(){`  
`class B implements A{`  
`public void hello(){}}` 
`new A(new B()).hello()`  
    
匿名内部类：舍去类的名称，但必须借助接口或父类  

`new A(){`  
`public void hello(){}`  
`};`  

λ表达式：注意使用λ表达式时，接口中只能由一个方法， 否则无法推导  
`a = ()->{`  //若方法有参数传入则在()内写入参数,参数可以不带类型;
`//hello的函数体`
`};`  
调用：`a.hello()`
  
多线程的λ表达式e.g.  
`main{`
`new Thread(()->{`  
`//重写的run方法的函数体`  
`}).start();`

## 线程状态转换
新生状态：线程对象被new之后就进入新生状态，拥有自己的工作空间  
就绪状态：调用start方法，进入就绪状态，但还未被调用运行；或阻塞事件接触；yield方法，切换到其他状态    
运行状态：前置必须为就绪状态，受到CPU调度，进入运行状态，运行Run方法  
阻塞状态：sleep();占有资源不允许别人使用; wait(),r让出资源给别人使用；join()插入队列，需等待别人释放资源;IO操作  
死亡状态：正常结束；stop()/destory()

### 线程终止
不推荐使用Stop或Destory  
应设置标志位  
### Sleep  
sleep为静态方法，必须写在线程题内，且不释放资源。
### yield
由运行状态直接进入就绪状态，让出资源，线程体内调用。
### join
A线程体内调用B线程的join  
`b.join()`则A线程被阻塞，先执行b线程的线程体，也可以传入时间参数，表示对A线程的阻塞时间的上限。


