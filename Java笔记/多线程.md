# 多线程
实现线程的方法：1、继承Thread类 2、实现Runnable接口 3、实现Callable接口  
Java虚拟机会等用户线程结束而不会等守护线程。  
实现线程时，必须重写Run方法，同时开启线程，是调用其Start方法，而不是Run方法。  
使用实现Runnable接口的方法创建线程时，注意Runnable并没有Start方法，必须创建一个Thread对象，以这个线程对象为构造参数，并调用Start  
e.g.  
`class A implements Runnable{}`  
`A a = new A()`  
`new Thread(a，str).start()`//a 不可以直接调用start，start是Thread的方法,str代表线程名称。  
当这种方法下，线程只使用一次，那么可以使用匿名类，而不用创建真正的A的对象。  
另外多线程操作相同资源时，多个Thread使用同样的A对象，但是构造器处传入不同的Thread名称。

e.g.  
`class A extends Thread{`  
`run(){}`//重写run方法  
`}`  
`A a = new A()`  
`a.start()`//调用Start，但并不一定立即执行，需要看CPU的分配  
注意Run方法不可以返回值，也不可以抛出异常。

第三种方法中，实现callable接口，不需要重写run方法，而是重写call方法  
call方法比run方法强大，可以抛出异常。但是在实现线程时需要借助服务，也不是调用start而是调用submit方法。  
最后需要释放资源，关闭服务，shutdownNow()

## 代理模式
### 静态代理  
两个角色：真实角色和代理角色。这两个角色都必须实现同一个接口。  
代理角色中必须有以接口为引用类型的真实角色对象成员。   
两个角色对接口中的方法分别进行不同的重写。

接口：  
`interface A{`  
`void hello()}`  
真实对象  
`class B implements A{`  
`public void hello(){}`  
代理对象  
`class C implements A{`
`private A m_a`  
`public void hello(){}`

`main(){`  
`new C(new B()).hello()}`

## λ表达式
用于简化简单的线程类：
外部类→静态内部类→局部内部类→匿名内部类→lambda表达式  
外部类：  
`interface A{`  
`void hello()}`  

`class B implements A{`  
`public void hello(){}}`  

`main(){`  
`A a = new B()`  
`a.hello()`  

静态内部类：把B写在Demo类内部  

`static class B implements A{`  
`public void hello(){}}`  
 
局部内部类:把类B写在方法中
 
`main(){`  
`class B implements A{`  
`public void hello(){}}` 
`new A(new B()).hello()`  
    
匿名内部类：舍去类的名称，但必须借助接口或父类  

`new A(){`  
`public void hello(){}`  
`};`  

λ表达式：注意使用λ表达式时，接口中只能由一个方法， 否则无法推导  
`a = ()->{`  //若方法有参数传入则在()内写入参数,参数可以不带类型;
`//hello的函数体`
`};`  
调用：`a.hello()`

